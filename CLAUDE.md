# Shopify Theme Development Guidelines

## Project Overview

This is a **Shopify theme development environment** using Vite + Bun. The project structure separates source code from compiled assets to maintain clean development workflows.

### Critical Project Rules

1. **NEVER create files directly in `assets/` directory** - all custom code goes in `frontend/` and gets compiled by Vite
2. **Always run `bun run build` after making changes** to compile frontend code into assets
3. **Commit both source and built assets** - the CI/CD pipeline validates that builds are in sync
4. **Use semantic class names** - NO utility-based CSS (no Tailwind-style classes)
5. **Mobile-first CSS** - always start with mobile styles, then use `@media` queries for larger screens

---

## Package Manager: Bun

Default to using Bun instead of Node.js.

- Use `bun <file>` instead of `node <file>` or `ts-node <file>`
- Use `bun test` instead of `jest` or `vitest`
- Use `bun install` instead of `npm install` or `yarn install` or `pnpm install`
- Use `bun run <script>` instead of `npm run <script>` or `yarn run <script>` or `pnpm run <script>`
- Bun automatically loads .env, so don't use dotenv

### Common Bun Commands

```bash
bun run dev              # Start development server (Vite + Shopify CLI)
bun run build            # Build production assets
bun run deploy           # Deploy to development environment
bun run deploy:staging   # Deploy to staging environment
```

---

## File Structure & Organization

### Directory Layout

```
shopify-theme/
‚îú‚îÄ‚îÄ frontend/              # üîπ ALL CUSTOM CODE HERE
‚îÇ   ‚îú‚îÄ‚îÄ entrypoints/      # Entry files (storefront.js, custom_styling.css)
‚îÇ   ‚îú‚îÄ‚îÄ scripts/          # JavaScript components and utilities
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ components/   # Reusable UI components (cart, product cards, etc.)
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ sections/     # Section-specific JavaScript
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ hooks/        # Utility hooks (lifecycle, debounce, etc.)
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ utils.js      # Helper functions
‚îÇ   ‚îî‚îÄ‚îÄ styles/           # Component-specific CSS files
‚îú‚îÄ‚îÄ assets/                # üî∏ COMPILED OUTPUT (auto-generated by Vite)
‚îÇ   ‚îú‚îÄ‚îÄ storefront.js     # Built from frontend/entrypoints/storefront.js
‚îÇ   ‚îî‚îÄ‚îÄ custom_styling.css # Built from frontend/entrypoints/custom_styling.css
‚îú‚îÄ‚îÄ layout/                # Shopify theme layout files
‚îú‚îÄ‚îÄ sections/              # Shopify theme sections
‚îú‚îÄ‚îÄ snippets/              # Shopify theme snippets
‚îÇ   ‚îî‚îÄ‚îÄ vite-tag.liquid   # Auto-generated by vite-plugin-shopify
‚îî‚îÄ‚îÄ templates/             # Shopify theme templates
```

### Key Principles

1. **Source Code Location**: ALL custom JavaScript and CSS must be created in `frontend/` directory
2. **Build Process**: Vite compiles `frontend/` ‚Üí `assets/` automatically
3. **Version Control**: Both source (`frontend/`) and compiled (`assets/`) are tracked in Git
4. **Shopify Upload**: Only `assets/`, `config/`, `layout/`, `sections/`, `snippets/`, and `templates/` are uploaded to Shopify

---

## CSS Guidelines

### 1. Mobile-First Responsive Design

**ALWAYS** start with mobile styles, then use `@media (min-width: ...)` for larger screens.

```css
/* ‚úÖ CORRECT: Mobile-first */
.product-card {
  padding: 1rem;                    /* Mobile default */
  grid-template-columns: 1fr;
}

@media (min-width: 768px) {
  .product-card {
    padding: 1.5rem;                /* Tablet */
    grid-template-columns: 1fr 1fr;
  }
}

@media (min-width: 1024px) {
  .product-card {
    padding: 2rem;                  /* Desktop */
    grid-template-columns: repeat(3, 1fr);
  }
}

/* ‚ùå WRONG: Desktop-first (avoid max-width) */
.product-card {
  padding: 2rem;
  grid-template-columns: repeat(3, 1fr);
}

@media (max-width: 768px) {
  .product-card {
    padding: 1rem;
  }
}
```

### 2. Semantic Class Names (NO Utility Classes)

Use descriptive class names that convey purpose, not appearance. Follow BEM-style naming conventions.

```css
/* ‚úÖ CORRECT: Semantic class names */
.product-card {
  display: flex;
  flex-direction: column;
  background-color: var(--color-surface);
  border-radius: var(--border-radius);
}

.product-card__title {
  font-size: 1.25rem;
  font-weight: 600;
  color: var(--color-text-primary);
}

.product-card__price {
  font-size: 1.125rem;
  color: var(--color-accent);
}

/* ‚ùå WRONG: Utility-based classes (Tailwind-style NOT allowed) */
.flex.flex-col.bg-white.rounded-lg {
  /* This approach is explicitly forbidden */
}
```

### 3. CSS Custom Properties

Use CSS variables for consistency and theming:

```css
:root {
  /* Colors */
  --color-primary: rgb(var(--color-button));
  --color-secondary: rgb(var(--color-accent));
  --color-text-primary: #1a1a1a;
  --color-text-secondary: #666;

  /* Spacing */
  --spacing-xs: 0.25rem;
  --spacing-sm: 0.5rem;
  --spacing-base: 1rem;
  --spacing-lg: 2rem;

  /* Transitions */
  --transition-fast: 150ms ease;
  --transition-base: 250ms ease;

  /* Borders */
  --border-radius: 4px;
}

.button-primary {
  background-color: var(--color-primary);
  padding: var(--spacing-sm) var(--spacing-base);
  border-radius: var(--border-radius);
  transition: background-color var(--transition-base);
}
```

### 4. Centralized Media Queries

Use consistent breakpoints across the project. Breakpoints are defined in the entrypoint file.

**Standard Breakpoints**:
- Mobile: Base styles (no media query)
- Tablet: `@media (min-width: 768px)`
- Desktop: `@media (min-width: 1024px)`
- Wide: `@media (min-width: 1280px)`

**For SCSS projects**, use the `respond-to` mixin:

```scss
.product-card {
  padding: spacing('sm');        // Mobile

  @include respond-to('md') {
    padding: spacing('base');    // Tablet+
  }

  @include respond-to('lg') {
    padding: spacing('lg');      // Desktop+
  }
}
```

**For plain CSS**, use the standard media query syntax:

```css
.product-card {
  padding: var(--spacing-sm);        /* Mobile */
}

@media (min-width: 768px) {
  .product-card {
    padding: var(--spacing-base);  /* Tablet+ */
  }
}

@media (min-width: 1024px) {
  .product-card {
    padding: var(--spacing-lg);    /* Desktop+ */
  }
}
```

### 5. CSS File Organization

- Create component-specific CSS files in `frontend/styles/`
- Import them in `frontend/entrypoints/custom_styling.css` (or `.scss`)
- Use clear, descriptive filenames (e.g., `product-card.css`, `cart-drawer.css`)

```css
/* frontend/entrypoints/custom_styling.css */
@import '../styles/product-card.css';
@import '../styles/cart-drawer.css';
@import '../styles/header-navigation.css';
```

---

## JavaScript Guidelines

### 1. Naming Conventions

- **Functions & Variables**: camelCase
- **Classes**: PascalCase
- **CSS Classes**: kebab-case
- **Files**: kebab-case for multi-word files

```javascript
// ‚úÖ CORRECT
function initProductForm() {
  const addToCartButton = document.querySelector('.add-to-cart');
  const formElement = document.getElementById('product-form');
}

class ProductCard {
  constructor(element) {
    this.element = element;
  }
}

// ‚ùå WRONG
function init_product_form() { }  // snake_case not allowed
function InitProductForm() { }    // PascalCase for functions not allowed
```

### 2. ES Modules and Import Alias

Always use ES module syntax with the `~` alias for imports:

```javascript
// ‚úÖ CORRECT: Use ~ alias for imports
import { consoleMessage, formatPrice } from '~/scripts/utils';
import { BaseComponent } from '~/scripts/components/baseComponent';
import ProductCard from '~/scripts/components/productCard';

// ‚ùå WRONG: CommonJS not supported
const utils = require('./utils');

// ‚ùå WRONG: Relative paths get messy
import { consoleMessage } from '../../scripts/utils';
```

The `~` alias is configured in `vite.config.js` and points to the `frontend/` directory.

### 3. Component Architecture

Use class-based components extending `BaseComponent` for reusable UI components:

```javascript
import { BaseComponent } from '~/scripts/components/baseComponent';

export class CartDrawer extends BaseComponent {
  constructor(selector) {
    super(selector);
    this.isOpen = false;
  }

  setupElement(element) {
    // Called for each element matching selector
    this.toggleButton = element.querySelector('.cart-toggle');
    this.closeButton = element.querySelector('.cart-close');

    this.toggleButton?.addEventListener('click', this.open.bind(this));
    this.closeButton?.addEventListener('click', this.close.bind(this));
  }

  open() {
    this.isOpen = true;
    this.element.classList.add('is-open');
    document.body.style.overflow = 'hidden';
  }

  close() {
    this.isOpen = false;
    this.element.classList.remove('is-open');
    document.body.style.overflow = '';
  }

  destroy() {
    // Cleanup event listeners
    this.toggleButton?.removeEventListener('click', this.open);
    this.closeButton?.removeEventListener('click', this.close);
    super.destroy();
  }
}

// Initialize
new CartDrawer('.cart-drawer');
```

### 4. Section Lifecycle Hooks

For Shopify section-specific code, use `useSectionLifecycle` to ensure proper initialization and cleanup in the theme editor:

```javascript
import { useSectionLifecycle } from '~/scripts/hooks/useSectionLifecycle';
import { ProductCard } from '~/scripts/components/productCard';

useSectionLifecycle('featured-collection', {
  onLoad: (root) => {
    // Initialize when section loads (page load or theme editor)
    const productCards = new ProductCard('.product-card', root);
    return { productCards }; // Return instance for cleanup
  },

  onUnload: (root, instance) => {
    // Cleanup when section unloads (theme editor)
    instance.productCards.destroy();
  }
});
```

**Why this matters**: Shopify's theme editor dynamically loads/unloads sections. Without proper lifecycle management, you'll have memory leaks and duplicate event listeners.

---

## Image Optimization

**CRITICAL**: Do NOT use Vite plugins for image optimization. Shopify has built-in image optimization that is superior to any build-time solution.

### Use Shopify's Native Image Optimization

Shopify provides automatic image optimization via the `image_url` filter with:
- Automatic WebP/AVIF format conversion
- Global CDN delivery
- On-demand resizing
- No build-time processing

**Correct approach** in Liquid templates:

```liquid
{%- comment -%} Responsive images with Shopify optimization {%- endcomment -%}
<img
  srcset="{{ product.featured_image | image_url: width: 375 }} 375w,
          {{ product.featured_image | image_url: width: 750 }} 750w,
          {{ product.featured_image | image_url: width: 1100 }} 1100w,
          {{ product.featured_image | image_url: width: 1500 }} 1500w"
  sizes="(min-width: 1024px) 50vw, (min-width: 768px) 70vw, 100vw"
  src="{{ product.featured_image | image_url: width: 750 }}"
  alt="{{ product.featured_image.alt | escape }}"
  loading="lazy"
  width="{{ product.featured_image.width }}"
  height="{{ product.featured_image.height }}"
>
```

**Why not Vite plugins?**
- Shopify's CDN is globally distributed and faster
- Format conversion happens automatically per browser
- No need to bloat build process with image processing
- On-demand resizing means you don't need to pre-generate sizes

---

## Development Workflow

### Creating New Components

When adding a new component (e.g., a product quick view):

1. **Create JavaScript file**: `frontend/scripts/components/productQuickView.js`
2. **Create CSS file**: `frontend/styles/product-quick-view.css`
3. **Import CSS**: Add to `frontend/entrypoints/custom_styling.css`
4. **Import JS**: Add to `frontend/entrypoints/storefront.js` (or use dynamic imports)
5. **Build assets**: Run `bun run build`
6. **Test in Shopify**: Use `bun run dev` to test with HMR
7. **Commit changes**: Commit both source files (`frontend/`) and built assets (`assets/`)

### Example: Adding a Product Quick View

```javascript
// frontend/scripts/components/productQuickView.js
import { BaseComponent } from '~/scripts/components/baseComponent';

export class ProductQuickView extends BaseComponent {
  constructor(selector) {
    super(selector);
  }

  setupElement(element) {
    const trigger = element.querySelector('.quick-view-trigger');
    trigger?.addEventListener('click', this.openQuickView.bind(this));
  }

  async openQuickView(event) {
    event.preventDefault();
    const productHandle = event.currentTarget.dataset.productHandle;
    // Fetch product data and show modal
  }
}
```

```css
/* frontend/styles/product-quick-view.css */
.product-quick-view {
  position: fixed;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  background: var(--color-surface);
  padding: var(--spacing-lg);
  border-radius: var(--border-radius);
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
  z-index: 1000;
}

@media (min-width: 768px) {
  .product-quick-view {
    padding: var(--spacing-xl);
    max-width: 800px;
  }
}
```

```javascript
// frontend/entrypoints/storefront.js
import { ProductQuickView } from '~/scripts/components/productQuickView';

// Initialize
new ProductQuickView('.product-card');
```

```css
/* frontend/entrypoints/custom_styling.css */
@import '../styles/product-quick-view.css';
```

Then build:
```bash
bun run build
```

---

## CORS and Theme Editor Development

### Problem: Mixed Content Blocking

Shopify theme editor runs on HTTPS, but local Vite dev server runs on HTTP. Browsers block this "mixed content."

### Solution: Cloudflare Tunnel

1. **Install cloudflared**:
   ```bash
   brew install cloudflared
   ```

2. **Enable tunnel in vite.config.js**:
   ```javascript
   export default defineConfig({
     plugins: [
       shopify({
         tunnel: true, // Enable Cloudflare tunnel
       }),
     ],
     server: {
       allowedHosts: 'all',
       // ... CORS headers
     }
   });
   ```

3. **Use Vite 6.0.8** (critical - newer versions have `allowedHosts` bug):
   ```bash
   bun add -d vite@6.0.8
   ```

4. **Start dev server**:
   ```bash
   bun run dev
   ```

The plugin will automatically create an HTTPS tunnel URL that Shopify can access.

---

## Security & Privacy

### Environment Variables

**NEVER commit sensitive data**:

```bash
# .env (gitignored)
SHOPIFY_API_KEY=your_api_key
SHOPIFY_API_SECRET=your_api_secret
SHOPIFY_STORE_URL=your-store.myshopify.com
```

### Excluded from Git

These files are automatically excluded (`.gitignore`):
- `.env` and all `.env.*` files
- `config/settings_data.json` (may contain store-specific settings)
- `shopify.theme.toml` (contains store credentials)
- `node_modules/`

### Excluded from Shopify Upload

These files are never uploaded to Shopify (`.shopifyignore`):
- `frontend/` (source code)
- `node_modules/`
- Configuration files (`vite.config.js`, `package.json`, etc.)
- Documentation files (`*.md`)
- Build tools and CI/CD (`.github/`)

Only compiled assets in `assets/` are uploaded.

---

## CI/CD Pipeline

### GitHub Actions Workflow

The `.github/workflows/build.yml` ensures that built assets are in sync:

1. Runs on every push/PR to `main` or `develop`
2. Installs dependencies with Bun
3. Builds Vite assets (`bun run build`)
4. **Validates** that built assets match committed assets
5. Fails if assets are out of sync

### Workflow for Developers

```bash
# Make changes to frontend code
# Edit frontend/scripts/components/myComponent.js

# Build assets
bun run build

# Commit BOTH source and built assets
git add frontend/ assets/
git commit -m "feat: Add myComponent functionality"
git push

# GitHub Actions will validate the build
```

If you forget to run `bun run build`, the CI pipeline will fail with:
```
‚ùå Built assets are out of sync. Run 'bun run build' and commit.
```

---

## Common Commands Reference

```bash
# Development
bun run dev                    # Start dev server (Vite + Shopify CLI)
bun run dev:staging            # Start dev with staging environment
bun run build                  # Build production assets

# Deployment
bun run deploy                 # Deploy to development environment
bun run deploy:staging         # Deploy to staging environment
bun run deploy:production      # Deploy to production environment

# Shopify CLI (direct)
shopify theme dev              # Start Shopify dev server
shopify theme push             # Push theme to Shopify
shopify theme pull             # Pull theme from Shopify
shopify theme list             # List all themes

# Vite (direct)
bun vite                       # Start Vite dev server
bun vite build                 # Build with Vite
bun vite preview               # Preview production build

# Utilities
bun run clean                  # Remove built assets
bun install                    # Install dependencies
```

---

## Project Memory & Context

### Key Technical Decisions

1. **Why Vite?** Sub-second HMR (<50ms) vs Webpack (1-5s), native ESM support, esbuild-powered transforms
2. **Why Bun?** 3-10x faster package installation, built-in TypeScript support, native bundler
3. **Why commit built assets?** Ensures production assets are reviewed in PRs, enables rollback via Git history
4. **Why no hash in filenames?** Shopify Liquid templates require stable asset paths, Shopify handles cache-busting via theme version
5. **Why `emptyOutDir: false`?** Preserves manually uploaded Shopify assets (fonts, images) not managed by Vite

### Project Conventions

- **Coding Style**: Prettier with 2-space indentation
- **Commit Messages**: Conventional Commits format (feat:, fix:, docs:, etc.)
- **Branch Strategy**: `main` for production, `develop` for staging
- **Code Review**: Required for all PRs before merging to main

### Common Gotchas

1. **Forgetting to build**: Always run `bun run build` after making changes
2. **Editing assets/ directly**: Changes will be overwritten on next build
3. **Using relative imports**: Use `~` alias instead (cleaner, more maintainable)
4. **Missing section lifecycle**: Components in sections need `useSectionLifecycle` for theme editor support
5. **Utility CSS classes**: Use semantic class names, not Tailwind-style utilities

---

## Questions to Ask When Starting a Task

Before implementing features, consider asking:

1. **Scope**: "Should this be a reusable component or section-specific code?"
2. **Mobile-first**: "What's the mobile experience first, then tablet/desktop?"
3. **Performance**: "Will this impact page load time? Should I lazy-load it?"
4. **Accessibility**: "Is this keyboard-navigable? Does it work with screen readers?"
5. **Theme editor**: "Does this need to work in Shopify's theme editor? (use `useSectionLifecycle`)"
6. **State management**: "Where should this state live? Component, global window object, or URL params?"
7. **Testing**: "How can I test this in the Shopify theme preview?"

---

## Available Subagents

This project includes specialized subagents in `.claude/agents/` that can be invoked for specific tasks. These agents are automatically available and can be called by name or delegated to based on task context.

### UI Design Agent (`ui-design`)

**When to use**: Designing UI components, creating CSS/SCSS styles, establishing design patterns, implementing responsive layouts.

**Capabilities**:
- Creates mobile-first responsive CSS/SCSS
- Implements semantic BEM-style class naming
- Designs component layouts and visual hierarchy
- Establishes design tokens and CSS custom properties
- Handles animations with reduced-motion support

**Example invocation**: "Design the product card component styles" or "Create responsive layout for the hero section"

### Tailwind Agent (`tailwind`)

**When to use**: ONLY when Tailwind CSS is the chosen styling approach for the project.

**Capabilities**:
- Implements Tailwind using `@apply` directives in CSS files
- **NEVER** uses inline utility classes in HTML/Liquid
- Enforces mobile-first responsive patterns with `@screen`
- Coordinates Tailwind config with Shopify theme settings

**Important**: If Tailwind is not configured, this agent redirects to UI Design agent.

**Example invocation**: "Convert this component to use Tailwind @apply patterns"

### Code Writer Agent (`code-writer`)

**When to use**: Writing JavaScript/TypeScript components, Liquid templates, implementing features.

**Capabilities**:
- Writes components extending `BaseComponent`
- Implements section lifecycle hooks for theme editor
- Creates Liquid sections and snippets
- Enforces 500-line soft limit for files
- Handles error handling and event cleanup

**Guidelines enforced**:
- Components MUST extend BaseComponent
- Section components MUST use `useSectionLifecycle`
- Files should stay under 500 lines (soft limit for Liquid)
- Proper naming conventions (_prefix for function-scoped vars)

**Example invocation**: "Implement the product quick view component" or "Create a featured collection section"

### Accessibility Agent (`accessibility`)

**When to use**: Implementing interactive components, forms, modals, navigation, or any UI requiring keyboard support and screen reader compatibility.

**Capabilities**:
- Reviews components for WCAG 2.1 AA compliance
- Implements focus management and keyboard navigation
- Adds proper ARIA attributes and roles
- Creates skip links and landmark regions
- Ensures color contrast compliance
- Implements reduced-motion preferences

**Example invocation**: "Review the cart drawer for accessibility" or "Add keyboard navigation to the product gallery"

### Liquid Agent (`liquid`)

**When to use**: Working with Shopify Liquid templates, section schemas, metafields, and Storefront API integration.

**Capabilities**:
- Liquid syntax and filter optimization
- Section and block architecture
- Schema configuration best practices
- Metafield and metaobject patterns
- Ajax API integration (Cart, Product Recommendations, Predictive Search)
- Performance optimization (avoiding N+1 queries)

**Example invocation**: "Create a featured collection section" or "Optimize the product template for performance"

### Performance Agent (`performance`)

**When to use**: Optimizing page speed, Core Web Vitals (LCP, CLS, INP), and overall performance for better conversion rates.

**Capabilities**:
- LCP/CLS/INP optimization strategies
- Image optimization with Shopify CDN
- Script loading strategies (defer, lazy load third-party)
- Critical CSS extraction and async loading
- Performance monitoring and Web Vitals reporting

**Example invocation**: "Audit the homepage for performance issues" or "Optimize the hero section for LCP"

### Agent Collaboration

These agents can work together on complex tasks:

1. **UI Design** ‚Üí **Code Writer**: Design hands off specs for implementation
2. **Code Writer** ‚Üí **Accessibility**: Request a11y review for interactive components
3. **UI Design** ‚Üí **Tailwind**: Coordinate when Tailwind is enabled
4. **Accessibility** ‚Üí **UI Design**: Review color contrast and focus states
5. **Liquid** ‚Üí **Performance**: Optimize Liquid for fewer iterations
6. **Performance** ‚Üí **Code Writer**: Implement lazy loading patterns

### Invoking Agents

Agents can be invoked:
- **Automatically**: Claude routes to appropriate agent based on task description
- **Explicitly**: Name the agent in your request (e.g., "use the accessibility agent to review...")
- **Via /agents command**: View and manage available agents

---

## Additional Resources

- [Vite Documentation](https://vitejs.dev/)
- [vite-plugin-shopify](https://github.com/barrel/shopify-vite)
- [Shopify Theme Development](https://shopify.dev/docs/themes)
- [Shopify Liquid Reference](https://shopify.dev/docs/api/liquid)
- [Bun Documentation](https://bun.sh/docs)

---

**Last Updated**: December 2025
**Maintainer**: Mikhail Arden
